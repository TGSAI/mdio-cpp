<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mdio-cpp: mdio::Variable&lt; T, R, M &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="favicon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mdio-cpp
   &#160;<span id="projectnumber">latest</span>
   </div>
   <div id="projectbrief">C++, Cloud native, scalable storage engine for various types of energy data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structmdio_1_1Variable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structmdio_1_1Variable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mdio::Variable&lt; T, R, M &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A templated struct representing an MDIO <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> with a tensorstore. This is an MDIO specified zarr V2 tensorstore variable. It represents the non-volitile (on-disk, in-cloud, etc.) data.  
 <a href="structmdio_1_1Variable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="variable_8h_source.html">variable.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_sequence</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable_1_1Interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing the half open interval of a dimension.  <a href="structmdio_1_1Variable_1_1Interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>make_index_sequence</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>make_index_sequence&lt; 0, I... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8fee312a59ae060d5946e4b4e3500f82"><td class="memItemLeft" align="right" valign="top"><a id="a8fee312a59ae060d5946e4b4e3500f82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Variable</b> (const std::string &amp;variableName, const std::string &amp;longName, const ::nlohmann::json &amp;metdata, const tensorstore::TensorStore&lt; T, R, M &gt; &amp;store, const std::shared_ptr&lt; std::shared_ptr&lt; <a class="el" href="classmdio_1_1UserAttributes.html">UserAttributes</a> &gt;&gt; attributes)</td></tr>
<tr class="separator:a8fee312a59ae060d5946e4b4e3500f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2735349d234b60b7f465af5b7380b1e7"><td class="memTemplParams" colspan="2"><a id="a2735349d234b60b7f465af5b7380b1e7"></a>
template&lt;typename SourceElement , DimensionIndex SourceRank, ReadWriteMode SourceMode&gt; </td></tr>
<tr class="memitem:a2735349d234b60b7f465af5b7380b1e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Variable</b> (const <a class="el" href="structmdio_1_1Variable.html">Variable</a>&lt; SourceElement, SourceRank, SourceMode &gt; &amp;other)</td></tr>
<tr class="separator:a2735349d234b60b7f465af5b7380b1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af425045bbd682a466383dcb99e244c6e"><td class="memTemplParams" colspan="2">template&lt;ArrayOriginKind OriginKind = offset_origin&gt; </td></tr>
<tr class="memitem:af425045bbd682a466383dcb99e244c6e"><td class="memTemplItemLeft" align="right" valign="top">Future&lt; <a class="el" href="structmdio_1_1VariableData.html">VariableData</a>&lt; T, R, OriginKind &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#af425045bbd682a466383dcb99e244c6e">Read</a> ()</td></tr>
<tr class="memdesc:af425045bbd682a466383dcb99e244c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the variable. Reads the data from the source variable. Provide an Open method for an existing file...  <a href="structmdio_1_1Variable.html#af425045bbd682a466383dcb99e244c6e">More...</a><br /></td></tr>
<tr class="separator:af425045bbd682a466383dcb99e244c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ba4f463cf01d9b0e410ab21e590a2b"><td class="memTemplParams" colspan="2">template&lt;ArrayOriginKind OriginKind = offset_origin&gt; </td></tr>
<tr class="memitem:ab4ba4f463cf01d9b0e410ab21e590a2b"><td class="memTemplItemLeft" align="right" valign="top">WriteFutures&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#ab4ba4f463cf01d9b0e410ab21e590a2b">Write</a> (const <a class="el" href="structmdio_1_1VariableData.html">VariableData</a>&lt; T, R, OriginKind &gt; source) const</td></tr>
<tr class="memdesc:ab4ba4f463cf01d9b0e410ab21e590a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to the variable. Writes the data from the source variable data to the target variable.  <a href="structmdio_1_1Variable.html#ab4ba4f463cf01d9b0e410ab21e590a2b">More...</a><br /></td></tr>
<tr class="separator:ab4ba4f463cf01d9b0e410ab21e590a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9e5aaad0b01a561659896818f402a7"><td class="memItemLeft" align="right" valign="top">IndexDomainView&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#aeb9e5aaad0b01a561659896818f402a7">dimensions</a> () const</td></tr>
<tr class="memdesc:aeb9e5aaad0b01a561659896818f402a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index domain view of the variable. Specifies the origin, shape and labels of the domain.  <a href="structmdio_1_1Variable.html#aeb9e5aaad0b01a561659896818f402a7">More...</a><br /></td></tr>
<tr class="separator:aeb9e5aaad0b01a561659896818f402a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c303df039cb5b4baa21f1528c58748"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a81c303df039cb5b4baa21f1528c58748">rank</a> () const</td></tr>
<tr class="memdesc:a81c303df039cb5b4baa21f1528c58748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rank of the variable.  <a href="structmdio_1_1Variable.html#a81c303df039cb5b4baa21f1528c58748">More...</a><br /></td></tr>
<tr class="separator:a81c303df039cb5b4baa21f1528c58748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab189197d3e907621c14018bc5ebedf62"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#ab189197d3e907621c14018bc5ebedf62">num_samples</a> () const</td></tr>
<tr class="memdesc:ab189197d3e907621c14018bc5ebedf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of samples in the variable.  <a href="structmdio_1_1Variable.html#ab189197d3e907621c14018bc5ebedf62">More...</a><br /></td></tr>
<tr class="separator:ab189197d3e907621c14018bc5ebedf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191176825860b75b456786a7bbfc9cad"><td class="memItemLeft" align="right" valign="top">DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a191176825860b75b456786a7bbfc9cad">dtype</a> () const</td></tr>
<tr class="memdesc:a191176825860b75b456786a7bbfc9cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type of the tensor store. The type of the store, T ~ void.  <a href="structmdio_1_1Variable.html#a191176825860b75b456786a7bbfc9cad">More...</a><br /></td></tr>
<tr class="separator:a191176825860b75b456786a7bbfc9cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b5f5daeea3c5981366776c48024a6a"><td class="memItemLeft" align="right" valign="top">Result&lt; Spec &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#af3b5f5daeea3c5981366776c48024a6a">spec</a> () const</td></tr>
<tr class="memdesc:af3b5f5daeea3c5981366776c48024a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the specification of the variable. Includes information about the compressor etc. This function returns an <code>mdio::Result</code> object containing the specification of the variable.  <a href="structmdio_1_1Variable.html#af3b5f5daeea3c5981366776c48024a6a">More...</a><br /></td></tr>
<tr class="separator:af3b5f5daeea3c5981366776c48024a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d2867e2e8586c02199c79ab7b618de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a64d2867e2e8586c02199c79ab7b618de">hasLabel</a> (const DimensionIdentifier &amp;labelToCheck) const</td></tr>
<tr class="memdesc:a64d2867e2e8586c02199c79ab7b618de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> contains a specified label.  <a href="structmdio_1_1Variable.html#a64d2867e2e8586c02199c79ab7b618de">More...</a><br /></td></tr>
<tr class="separator:a64d2867e2e8586c02199c79ab7b618de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f66203aef204badd74daedf0da397c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdio_1_1RangeDescriptor.html">RangeDescriptor</a>&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a79f66203aef204badd74daedf0da397c">sliceInRange</a> (const <a class="el" href="structmdio_1_1RangeDescriptor.html">RangeDescriptor</a>&lt; Index &gt; &amp;desc) const</td></tr>
<tr class="memdesc:a79f66203aef204badd74daedf0da397c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps a slice descriptor to the domain of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>. Intended for internal use.  <a href="structmdio_1_1Variable.html#a79f66203aef204badd74daedf0da397c">More...</a><br /></td></tr>
<tr class="separator:a79f66203aef204badd74daedf0da397c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d25de55e7e7366248c4578d14d2c136"><td class="memItemLeft" align="right" valign="top"><a id="a7d25de55e7e7366248c4578d14d2c136"></a>
Result&lt; <a class="el" href="structmdio_1_1Variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a7d25de55e7e7366248c4578d14d2c136">slice</a> (const std::vector&lt; <a class="el" href="structmdio_1_1RangeDescriptor.html">RangeDescriptor</a>&lt; Index &gt;&gt; &amp;slices)</td></tr>
<tr class="memdesc:a7d25de55e7e7366248c4578d14d2c136"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of the <code>slice</code> method that takes a vector of RangeDescriptors. This method is limited to <code>internal::kMaxNumSlices</code> slices. This overload should only ever be used when a runtime number of slices must be generated. <br /></td></tr>
<tr class="separator:a7d25de55e7e7366248c4578d14d2c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f8d0b0dd2580e9add2b7b118076aa1"><td class="memTemplParams" colspan="2">template&lt;typename... Descriptors&gt; </td></tr>
<tr class="memitem:ae6f8d0b0dd2580e9add2b7b118076aa1"><td class="memTemplItemLeft" align="right" valign="top">Result&lt; <a class="el" href="structmdio_1_1Variable.html">Variable</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#ae6f8d0b0dd2580e9add2b7b118076aa1">slice</a> (const Descriptors &amp;... descriptors) const</td></tr>
<tr class="memdesc:ae6f8d0b0dd2580e9add2b7b118076aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> along the specified dimensions and returns the resulting sub-Variable. This slice is performed as a half open interval. Dimensions that are not described will remain fully intact.  <a href="structmdio_1_1Variable.html#ae6f8d0b0dd2580e9add2b7b118076aa1">More...</a><br /></td></tr>
<tr class="separator:ae6f8d0b0dd2580e9add2b7b118076aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148239da2dc59066ea30edb9d391208"><td class="memItemLeft" align="right" valign="top">Result&lt; nlohmann::json &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#aa148239da2dc59066ea30edb9d391208">get_spec</a> () const</td></tr>
<tr class="memdesc:aa148239da2dc59066ea30edb9d391208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the spec of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> as a JSON object.  <a href="structmdio_1_1Variable.html#aa148239da2dc59066ea30edb9d391208">More...</a><br /></td></tr>
<tr class="separator:aa148239da2dc59066ea30edb9d391208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaa5bcd4353616096acbfeabb7946fe"><td class="memItemLeft" align="right" valign="top">Result&lt; std::vector&lt; DimensionIndex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a4aaa5bcd4353616096acbfeabb7946fe">get_chunk_shape</a> () const</td></tr>
<tr class="memdesc:a4aaa5bcd4353616096acbfeabb7946fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the specified chunk shape of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> if it exists.  <a href="structmdio_1_1Variable.html#a4aaa5bcd4353616096acbfeabb7946fe">More...</a><br /></td></tr>
<tr class="separator:a4aaa5bcd4353616096acbfeabb7946fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d38478850049594eb458a3ddd4cb1e"><td class="memItemLeft" align="right" valign="top">Result&lt; std::vector&lt; DimensionIndex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a11d38478850049594eb458a3ddd4cb1e">get_store_shape</a> () const</td></tr>
<tr class="memdesc:a11d38478850049594eb458a3ddd4cb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the entire shape of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> if it exists.  <a href="structmdio_1_1Variable.html#a11d38478850049594eb458a3ddd4cb1e">More...</a><br /></td></tr>
<tr class="separator:a11d38478850049594eb458a3ddd4cb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee667e4ed0e628fda1240308a3322f23"><td class="memTemplParams" colspan="2">template&lt;typename T_attrs  = float&gt; </td></tr>
<tr class="memitem:aee667e4ed0e628fda1240308a3322f23"><td class="memTemplItemLeft" align="right" valign="top">Result&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#aee667e4ed0e628fda1240308a3322f23">UpdateAttributes</a> (const nlohmann::json &amp;newAttrs)</td></tr>
<tr class="memdesc:aee667e4ed0e628fda1240308a3322f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to safely update the user attributes of a <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> (["metadata"]["attributes"] and/or ["metadata"]["statsV1"]).  <a href="structmdio_1_1Variable.html#aee667e4ed0e628fda1240308a3322f23">More...</a><br /></td></tr>
<tr class="separator:aee667e4ed0e628fda1240308a3322f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd03f3f669daa74f6b0e4be1623cfbd7"><td class="memItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#acd03f3f669daa74f6b0e4be1623cfbd7">GetAttributes</a> () const</td></tr>
<tr class="memdesc:acd03f3f669daa74f6b0e4be1623cfbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the User Attributes of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> as a JSON object. Returned object is expected to have a parent key of "attributes". This is expected to be the exact copy of the attributes field.  <a href="structmdio_1_1Variable.html#acd03f3f669daa74f6b0e4be1623cfbd7">More...</a><br /></td></tr>
<tr class="separator:acd03f3f669daa74f6b0e4be1623cfbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af588da2fe10fd11f396cbc04358d2e"><td class="memItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a4af588da2fe10fd11f396cbc04358d2e">getMetadata</a> () const</td></tr>
<tr class="memdesc:a4af588da2fe10fd11f396cbc04358d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the entire metadata of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>. Returned object is expected to have a parent key of "metadata".  <a href="structmdio_1_1Variable.html#a4af588da2fe10fd11f396cbc04358d2e">More...</a><br /></td></tr>
<tr class="separator:a4af588da2fe10fd11f396cbc04358d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef8f25d1575106456734024fad0eff9"><td class="memItemLeft" align="right" valign="top">const nlohmann::json&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a4ef8f25d1575106456734024fad0eff9">getReducedMetadata</a> () const</td></tr>
<tr class="memdesc:a4ef8f25d1575106456734024fad0eff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reduced version of the metadata NOTE: This may only be useful for internal uses. See <code><a class="el" href="structmdio_1_1Variable.html#a4af588da2fe10fd11f396cbc04358d2e" title="Gets the entire metadata of the Variable. Returned object is expected to have a parent key of &quot;metada...">getMetadata()</a></code> for the full metadata. This version should lack the mutable <a class="el" href="classmdio_1_1UserAttributes.html">UserAttributes</a> portions, if they exist.  <a href="structmdio_1_1Variable.html#a4ef8f25d1575106456734024fad0eff9">More...</a><br /></td></tr>
<tr class="separator:a4ef8f25d1575106456734024fad0eff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fee24ea3e4445550af3f8019014d63"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a09fee24ea3e4445550af3f8019014d63">was_updated</a> () const</td></tr>
<tr class="memdesc:a09fee24ea3e4445550af3f8019014d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the User Attributes has changed in the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>.  <a href="structmdio_1_1Variable.html#a09fee24ea3e4445550af3f8019014d63">More...</a><br /></td></tr>
<tr class="separator:a09fee24ea3e4445550af3f8019014d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9656b9c6fff49c5dfb066d0fe3cb020e"><td class="memTemplParams" colspan="2">template&lt;typename... DimensionIdentifier&gt; </td></tr>
<tr class="memitem:a9656b9c6fff49c5dfb066d0fe3cb020e"><td class="memTemplItemLeft" align="right" valign="top">mdio::Result&lt; std::vector&lt; <a class="el" href="structmdio_1_1Variable_1_1Interval.html">Interval</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a9656b9c6fff49c5dfb066d0fe3cb020e">get_intervals</a> (const DimensionIdentifier &amp;... labels) const</td></tr>
<tr class="memdesc:a9656b9c6fff49c5dfb066d0fe3cb020e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the domain of the whole <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> or selected dimensions.  <a href="structmdio_1_1Variable.html#a9656b9c6fff49c5dfb066d0fe3cb020e">More...</a><br /></td></tr>
<tr class="separator:a9656b9c6fff49c5dfb066d0fe3cb020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee6f9439f537598a49460e8ed30fdc6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a8ee6f9439f537598a49460e8ed30fdc6">get_variable_name</a> () const</td></tr>
<tr class="memdesc:a8ee6f9439f537598a49460e8ed30fdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the variable.  <a href="structmdio_1_1Variable.html#a8ee6f9439f537598a49460e8ed30fdc6">More...</a><br /></td></tr>
<tr class="separator:a8ee6f9439f537598a49460e8ed30fdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f06db2494c8512ae0f1409b92632c7b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a2f06db2494c8512ae0f1409b92632c7b">get_long_name</a> () const</td></tr>
<tr class="memdesc:a2f06db2494c8512ae0f1409b92632c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the long name of the variable.  <a href="structmdio_1_1Variable.html#a2f06db2494c8512ae0f1409b92632c7b">More...</a><br /></td></tr>
<tr class="separator:a2f06db2494c8512ae0f1409b92632c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa094a7e6a0ae874f966c4e39cb121581"><td class="memItemLeft" align="right" valign="top">const tensorstore::TensorStore&lt; T, R, M &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#aa094a7e6a0ae874f966c4e39cb121581">get_store</a> () const</td></tr>
<tr class="memdesc:aa094a7e6a0ae874f966c4e39cb121581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying tensorstore of the variable.  <a href="structmdio_1_1Variable.html#aa094a7e6a0ae874f966c4e39cb121581">More...</a><br /></td></tr>
<tr class="separator:aa094a7e6a0ae874f966c4e39cb121581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4110cb61acedde49783def9b6f329b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a1b4110cb61acedde49783def9b6f329b">should_publish</a> () const</td></tr>
<tr class="memdesc:a1b4110cb61acedde49783def9b6f329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the metadata should get republished.  <a href="structmdio_1_1Variable.html#a1b4110cb61acedde49783def9b6f329b">More...</a><br /></td></tr>
<tr class="separator:a1b4110cb61acedde49783def9b6f329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a83593c8e537a55f715427c2d721b9f20"><td class="memTemplParams" colspan="2">template&lt;typename... Option&gt; </td></tr>
<tr class="memitem:a83593c8e537a55f715427c2d721b9f20"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt;(tensorstore::IsCompatibleOptionSequence&lt; TransactionalOpenOptions, Option... &gt;), Future&lt; <a class="el" href="structmdio_1_1Variable.html">Variable</a>&lt; T, R, M &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdio_1_1Variable.html#a83593c8e537a55f715427c2d721b9f20">Open</a> (const nlohmann::json &amp;json_spec, Option &amp;&amp;... option)</td></tr>
<tr class="memdesc:a83593c8e537a55f715427c2d721b9f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a variable with the specified options. Provide an Open method for an existing file...  <a href="structmdio_1_1Variable.html#a83593c8e537a55f715427c2d721b9f20">More...</a><br /></td></tr>
<tr class="separator:a83593c8e537a55f715427c2d721b9f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a22e7092f023c82ef24ea9140b8cdc96c"><td class="memItemLeft" align="right" valign="top"><a id="a22e7092f023c82ef24ea9140b8cdc96c"></a>
std::shared_ptr&lt; std::shared_ptr&lt; <a class="el" href="classmdio_1_1UserAttributes.html">UserAttributes</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>attributes</b></td></tr>
<tr class="separator:a22e7092f023c82ef24ea9140b8cdc96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab4359531a5eddcc13012c2687873dae8"><td class="memItemLeft" align="right" valign="top"><a id="ab4359531a5eddcc13012c2687873dae8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structmdio_1_1Variable.html">Variable</a> &amp;obj)</td></tr>
<tr class="separator:ab4359531a5eddcc13012c2687873dae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt;<br />
class mdio::Variable&lt; T, R, M &gt;</h3>

<p>A templated struct representing an MDIO <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> with a tensorstore. This is an MDIO specified zarr V2 tensorstore variable. It represents the non-volitile (on-disk, in-cloud, etc.) data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data stored in the tensorstore. </td></tr>
    <tr><td class="paramname">R</td><td>The rank of the tensorstore. </td></tr>
    <tr><td class="paramname">M</td><td>The read-write mode of the tensorstore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableName</td><td>The name of the variable. </td></tr>
    <tr><td class="paramname">longName</td><td>The optional long name of the variable. </td></tr>
    <tr><td class="paramname">metadata</td><td>Any metadata associated with the variable. </td></tr>
    <tr><td class="paramname">store</td><td>The underlying Tensorstore. </td></tr>
    <tr><td class="paramname">attributes</td><td>The user attributes associated with the variable. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb9e5aaad0b01a561659896818f402a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9e5aaad0b01a561659896818f402a7">&#9670;&nbsp;</a></span>dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexDomainView&lt;R&gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index domain view of the variable. Specifies the origin, shape and labels of the domain. </p>
<dl class="section return"><dt>Returns</dt><dd>The index domain view of the variable. </dd></dl>

</div>
</div>
<a id="a191176825860b75b456786a7bbfc9cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191176825860b75b456786a7bbfc9cad">&#9670;&nbsp;</a></span>dtype()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::dtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data type of the tensor store. The type of the store, T ~ void. </p>
<dl class="section return"><dt>Returns</dt><dd>The data type of the tensor store. </dd></dl>

</div>
</div>
<a id="a4aaa5bcd4353616096acbfeabb7946fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaa5bcd4353616096acbfeabb7946fe">&#9670;&nbsp;</a></span>get_chunk_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&lt;std::vector&lt;DimensionIndex&gt; &gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::get_chunk_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the specified chunk shape of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> if it exists. </p>
<p><b>Usage</b> </p><div class="fragment"><div class="line"> MDIO_ASSIGN_OR_RETURN(<span class="keyword">auto</span> chunkShape, velocity.get_chunk_shape());</div>
<div class="line"> <span class="comment">// Build descriptors to slice out a swath, here we will get every chunk in</span></div>
<div class="line"> <span class="comment">// the z-direction</span></div>
<div class="line"><a class="code" href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor&lt;Index&gt;</a> desc1 = {<span class="stringliteral">&quot;inline&quot;</span>, chunkShape[0],</div>
<div class="line">chunkShape[0] * 2, 1}; <a class="code" href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor&lt;Index&gt;</a> desc2 = {<span class="stringliteral">&quot;crossline&quot;</span>,</div>
<div class="line">chunkShape[1], chunkShape[1] * 2, 1};</div>
<div class="ttc" id="astructmdio_1_1RangeDescriptor_html"><div class="ttname"><a href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor</a></div><div class="ttdoc">A descriptor for slicing a Variable or Dataset.</div><div class="ttdef"><b>Definition:</b> variable.h:76</div></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>An NotFoundError if the chunk shape could not be retrieved, otherwise a vector of the chunk shape. </dd></dl>

</div>
</div>
<a id="a9656b9c6fff49c5dfb066d0fe3cb020e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9656b9c6fff49c5dfb066d0fe3cb020e">&#9670;&nbsp;</a></span>get_intervals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<div class="memtemplate">
template&lt;typename... DimensionIdentifier&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mdio::Result&lt;std::vector&lt;<a class="el" href="structmdio_1_1Variable_1_1Interval.html">Interval</a>&gt; &gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::get_intervals </td>
          <td>(</td>
          <td class="paramtype">const DimensionIdentifier &amp;...&#160;</td>
          <td class="paramname"><em>labels</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the domain of the whole <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> or selected dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labels</td><td>The DimensionIdentifier(s) of the dimensions to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the domain of the selected dimensions, or the whole domain if no labels are provided. </dd></dl>

</div>
</div>
<a id="a2f06db2494c8512ae0f1409b92632c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f06db2494c8512ae0f1409b92632c7b">&#9670;&nbsp;</a></span>get_long_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::get_long_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the long name of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>The long name of the variable. </dd></dl>

</div>
</div>
<a id="aa148239da2dc59066ea30edb9d391208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa148239da2dc59066ea30edb9d391208">&#9670;&nbsp;</a></span>get_spec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&lt;nlohmann::json&gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::get_spec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the spec of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> as a JSON object. </p>
<dl class="section return"><dt>Returns</dt><dd>A JSON object representing the spec of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>. </dd></dl>

</div>
</div>
<a id="aa094a7e6a0ae874f966c4e39cb121581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa094a7e6a0ae874f966c4e39cb121581">&#9670;&nbsp;</a></span>get_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const tensorstore::TensorStore&lt;T, R, M&gt;&amp; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::get_store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the underlying tensorstore of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>The tensorstore of the variable. </dd></dl>

</div>
</div>
<a id="a11d38478850049594eb458a3ddd4cb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d38478850049594eb458a3ddd4cb1e">&#9670;&nbsp;</a></span>get_store_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&lt;std::vector&lt;DimensionIndex&gt; &gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::get_store_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the entire shape of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> if it exists. </p>
<dl class="section return"><dt>Returns</dt><dd>A NotFoundError if the shape could not be retrieved, otherwise a vector of the shape. </dd></dl>

</div>
</div>
<a id="a8ee6f9439f537598a49460e8ed30fdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee6f9439f537598a49460e8ed30fdc6">&#9670;&nbsp;</a></span>get_variable_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::get_variable_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the variable. </dd></dl>

</div>
</div>
<a id="acd03f3f669daa74f6b0e4be1623cfbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd03f3f669daa74f6b0e4be1623cfbd7">&#9670;&nbsp;</a></span>GetAttributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nlohmann::json <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::GetAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the User Attributes of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> as a JSON object. Returned object is expected to have a parent key of "attributes". This is expected to be the exact copy of the attributes field. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://mdio-python.readthedocs.io/en/v1/data_models/version_1.html#mdio.schema.v1.variable.VariableMetadata.attributes">https://mdio-python.readthedocs.io/en/v1/data_models/version_1.html#mdio.schema.v1.variable.VariableMetadata.attributes</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The User Attributes in JSON form. </dd></dl>

</div>
</div>
<a id="a4af588da2fe10fd11f396cbc04358d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af588da2fe10fd11f396cbc04358d2e">&#9670;&nbsp;</a></span>getMetadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nlohmann::json <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::getMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the entire metadata of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>. Returned object is expected to have a parent key of "metadata". </p>
<dl class="section return"><dt>Returns</dt><dd>The metadata in JSON form </dd></dl>

</div>
</div>
<a id="a4ef8f25d1575106456734024fad0eff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef8f25d1575106456734024fad0eff9">&#9670;&nbsp;</a></span>getReducedMetadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const nlohmann::json <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::getReducedMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reduced version of the metadata NOTE: This may only be useful for internal uses. See <code><a class="el" href="structmdio_1_1Variable.html#a4af588da2fe10fd11f396cbc04358d2e" title="Gets the entire metadata of the Variable. Returned object is expected to have a parent key of &quot;metada...">getMetadata()</a></code> for the full metadata. This version should lack the mutable <a class="el" href="classmdio_1_1UserAttributes.html">UserAttributes</a> portions, if they exist. </p>
<dl class="section return"><dt>Returns</dt><dd>The reduced metadata in JSON form </dd></dl>

</div>
</div>
<a id="a64d2867e2e8586c02199c79ab7b618de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d2867e2e8586c02199c79ab7b618de">&#9670;&nbsp;</a></span>hasLabel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::hasLabel </td>
          <td>(</td>
          <td class="paramtype">const DimensionIdentifier &amp;&#160;</td>
          <td class="paramname"><em>labelToCheck</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> contains a specified label. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelToCheck</td><td>The label to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> contains the label, false otherwise </dd></dl>

</div>
</div>
<a id="ab189197d3e907621c14018bc5ebedf62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab189197d3e907621c14018bc5ebedf62">&#9670;&nbsp;</a></span>num_samples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::num_samples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of samples in the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>Index The number of samples in the variable. </dd></dl>

</div>
</div>
<a id="a83593c8e537a55f715427c2d721b9f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83593c8e537a55f715427c2d721b9f20">&#9670;&nbsp;</a></span>Open()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<div class="memtemplate">
template&lt;typename... Option&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if_t&lt;(tensorstore::IsCompatibleOptionSequence&lt; TransactionalOpenOptions, Option...&gt;), Future&lt;<a class="el" href="structmdio_1_1Variable.html">Variable</a>&lt;T, R, M&gt; &gt; &gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::Open </td>
          <td>(</td>
          <td class="paramtype">const nlohmann::json &amp;&#160;</td>
          <td class="paramname"><em>json_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Option &amp;&amp;...&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a variable with the specified options. Provide an Open method for an existing file... </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the variable. Defaults to <code>void</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The rank of the variable. Defaults to <code>mdio::dynamic_rank</code>. </td></tr>
    <tr><td class="paramname">M</td><td>The read/write mode of the variable. Defaults to <code>mdio::ReadWriteMode::dynamic</code>. </td></tr>
    <tr><td class="paramname">Option</td><td>The options to use when opening the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json_spec</td><td>The JSON specification of the variable to open. </td></tr>
    <tr><td class="paramname">option</td><td>The options to use when opening the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>mdio::Future</code> that resolves to a <code><a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a></code> object.</dd></dl>
<p>This function opens an existing <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> with the specified options. </p>

</div>
</div>
<a id="a81c303df039cb5b4baa21f1528c58748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c303df039cb5b4baa21f1528c58748">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the rank of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t The rank of the variable. </dd></dl>

</div>
</div>
<a id="af425045bbd682a466383dcb99e244c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af425045bbd682a466383dcb99e244c6e">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<div class="memtemplate">
template&lt;ArrayOriginKind OriginKind = offset_origin&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt;<a class="el" href="structmdio_1_1VariableData.html">VariableData</a>&lt;T, R, OriginKind&gt; &gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the variable. Reads the data from the source variable. Provide an Open method for an existing file... </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to be read. </td></tr>
    <tr><td class="paramname">R</td><td>The tensorstore rank of the data to be read. </td></tr>
    <tr><td class="paramname">M</td><td>The read/write mode of the data to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable</td><td>A <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> object with the source store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future of <a class="el" href="structmdio_1_1VariableData.html" title="The in-memory representation of the data This object should only be constructed through the Variable:...">VariableData</a> that will be ready when the read is complete. </dd></dl>

</div>
</div>
<a id="a1b4110cb61acedde49783def9b6f329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4110cb61acedde49783def9b6f329b">&#9670;&nbsp;</a></span>should_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::should_publish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the metadata should get republished. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the metadata should get republished. </dd></dl>

</div>
</div>
<a id="ae6f8d0b0dd2580e9add2b7b118076aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f8d0b0dd2580e9add2b7b118076aa1">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<div class="memtemplate">
template&lt;typename... Descriptors&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&lt;<a class="el" href="structmdio_1_1Variable.html">Variable</a>&gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const Descriptors &amp;...&#160;</td>
          <td class="paramname"><em>descriptors</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slices the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> along the specified dimensions and returns the resulting sub-Variable. This slice is performed as a half open interval. Dimensions that are not described will remain fully intact. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The step of the descriptor object must be 1. </dd>
<dd>
The start of the descriptor object must be less than the stop. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The resulting <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> will be sliced along the specified dimensions within it's domain. If the slice lay outside of the domain of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>, the slice will be clamped to the domain. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptors</td><td>The descriptors used to specify the slice.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Usage</b> This provides an example of slicing the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> along the inline and crossline dimensions. </p><div class="fragment"><div class="line"><a class="code" href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor&lt;Index&gt;</a> desc1 = {<span class="stringliteral">&quot;inline&quot;</span>, 0, 100, 1};</div>
<div class="line"><a class="code" href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor&lt;Index&gt;</a> desc2 = {<span class="stringliteral">&quot;crossline&quot;</span>, 0, 200, 1};</div>
<div class="line">MDIO_ASSIGN_OR_RETURN(<span class="keyword">auto</span> sliced_velocity, velocity.slice(desc1, desc2));</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>An <code>mdio::Result</code> object containing the resulting sub-Variable. </dd></dl>

</div>
</div>
<a id="a79f66203aef204badd74daedf0da397c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f66203aef204badd74daedf0da397c">&#9670;&nbsp;</a></span>sliceInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdio_1_1RangeDescriptor.html">RangeDescriptor</a>&lt;Index&gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::sliceInRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdio_1_1RangeDescriptor.html">RangeDescriptor</a>&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamps a slice descriptor to the domain of the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>. Intended for internal use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>The slice descriptor to be clamped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice descriptor that will not go out-of-bounds for the given <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>. </dd></dl>

</div>
</div>
<a id="af3b5f5daeea3c5981366776c48024a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b5f5daeea3c5981366776c48024a6a">&#9670;&nbsp;</a></span>spec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&lt;Spec&gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::spec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the specification of the variable. Includes information about the compressor etc. This function returns an <code>mdio::Result</code> object containing the specification of the variable. </p>
<dl class="section return"><dt>Returns</dt><dd>An <code>mdio::Result</code> object containing the specification of the variable. </dd></dl>

</div>
</div>
<a id="aee667e4ed0e628fda1240308a3322f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee667e4ed0e628fda1240308a3322f23">&#9670;&nbsp;</a></span>UpdateAttributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<div class="memtemplate">
template&lt;typename T_attrs  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&lt;void&gt; <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::UpdateAttributes </td>
          <td>(</td>
          <td class="paramtype">const nlohmann::json &amp;&#160;</td>
          <td class="paramname"><em>newAttrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to safely update the user attributes of a <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> (["metadata"]["attributes"] and/or ["metadata"]["statsV1"]). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_attrs</td><td>The optional type of the histogram. Must be either int32_t or float (Default: float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAttrs</td><td>The JSON representation of a UserAttribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OK status if the attributes were successfully updated, otherwise an error and the attributes remain unchanged.</dd></dl>
<p><b>Intended_Usage</b> </p><div class="fragment"><div class="line"><span class="comment">// Status check ignored for brevity</span></div>
<div class="line"><span class="keyword">auto</span> var = my_dataset.variables.at(<span class="stringliteral">&quot;my_variable_key&quot;</span>).value();</div>
<div class="line">nlohmann::json to_update = var.GetAttributes();</div>
<div class="line">to_update[<span class="stringliteral">&quot;attributes&quot;</span>][<span class="stringliteral">&quot;new_attr&quot;</span>] = <span class="stringliteral">&quot;new_value&quot;</span>;</div>
<div class="line">std::vector&lt;int32_t&gt; binCenters;</div>
<div class="line"><span class="comment">// Populate with your data as needed</span></div>
<div class="line">to_update[<span class="stringliteral">&quot;statsV1&quot;</span>][<span class="stringliteral">&quot;histogram&quot;</span>][<span class="stringliteral">&quot;binCenters&quot;</span>] = binCenters;</div>
<div class="line"><span class="comment">// NOTE: The vector is of type int32_t. We must pass the type as a</span></div>
<div class="line"><span class="keyword">template</span> argument.</div>
<div class="line">auto update_result = var.UpdateAttributes&lt;int32_t&gt;(to_update);</div>
<div class="line"><span class="keywordflow">if</span> (!update_result.status().ok()) {</div>
<div class="line">     <span class="comment">// In this case nothing will happen. We output an error and move on</span></div>
<div class="line">     <span class="comment">// with what previously existed.</span></div>
<div class="line">     std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to update attributes: &quot;</span> &lt;&lt;</div>
<div class="line">     update_result.status() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> NOTE: This does not commit changes to durable media. Please see CommitMetadata method in the <a class="el" href="classmdio_1_1Dataset.html" title="The Dataset class The dataset represents a collection of variables sharing a common grid.">Dataset</a> to commit changes. </p>

</div>
</div>
<a id="a09fee24ea3e4445550af3f8019014d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fee24ea3e4445550af3f8019014d63">&#9670;&nbsp;</a></span>was_updated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::was_updated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the User Attributes has changed in the <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the User Attributes has changed, false otherwise. </dd></dl>

</div>
</div>
<a id="ab4ba4f463cf01d9b0e410ab21e590a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ba4f463cf01d9b0e410ab21e590a2b">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, DimensionIndex R = dynamic_rank, ReadWriteMode M = ReadWriteMode::dynamic&gt; </div>
<div class="memtemplate">
template&lt;ArrayOriginKind OriginKind = offset_origin&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WriteFutures <a class="el" href="structmdio_1_1Variable.html">mdio::Variable</a>&lt; T, R, M &gt;::Write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdio_1_1VariableData.html">VariableData</a>&lt; T, R, OriginKind &gt;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to the variable. Writes the data from the source variable data to the target variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A <a class="el" href="structmdio_1_1VariableData.html" title="The in-memory representation of the data This object should only be constructed through the Variable:...">VariableData</a> object with the data to write. This is the in-memory representation of the data. </td></tr>
    <tr><td class="paramname">target</td><td>A <a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">Variable</a> object with the target store. This is the non-volitile representation of the data.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Usage</b> This provides an example of writing the data from the source variable data to the target variable. </p><div class="fragment"><div class="line">MDIO_ASSIGN_OR_RETURN(<span class="keyword">auto</span> velocity, <a class="code" href="structmdio_1_1Variable.html">mdio::Variable&lt;&gt;::Open</a>(velocity_path,</div>
<div class="line">                                                 <a class="code" href="namespacemdio_1_1constants.html#a6788ecca2934df06723540a3c9ad2481">mdio::constants::kOpen</a>));</div>
<div class="line"><span class="comment">// Get an empty version of the Variable.</span></div>
<div class="line">MDIO_ASSIGN_OR_RETURN(<span class="keyword">auto</span> velocityData, <a class="code" href="namespacemdio.html#a235692fcef4cfccfba94767404d2b11d">mdio::from_variable</a>(velocity));</div>
<div class="line"><span class="comment">// Do some manipulation of velocity here before writing it out.</span></div>
<div class="line"><span class="keyword">auto</span> velocityWriteFuture = velocity.Write(velocityData);</div>
<div class="line"><span class="comment">// This is a future. It will be ready when the write is complete.</span></div>
<div class="ttc" id="anamespacemdio_1_1constants_html_a6788ecca2934df06723540a3c9ad2481"><div class="ttname"><a href="namespacemdio_1_1constants.html#a6788ecca2934df06723540a3c9ad2481">mdio::constants::kOpen</a></div><div class="ttdeci">constexpr auto kOpen</div><div class="ttdoc">Open a pre-existing file.</div><div class="ttdef"><b>Definition:</b> impl.h:110</div></div>
<div class="ttc" id="anamespacemdio_html_a235692fcef4cfccfba94767404d2b11d"><div class="ttname"><a href="namespacemdio.html#a235692fcef4cfccfba94767404d2b11d">mdio::from_variable</a></div><div class="ttdeci">Result&lt; VariableData&lt; T, R, OriginKind &gt; &gt; from_variable(const Variable&lt;&gt; &amp;variable)</div><div class="ttdoc">Allocates a VariableData object with the specified dtype and fill value. Intended behavior is to fill...</div><div class="ttdef"><b>Definition:</b> variable.h:1851</div></div>
<div class="ttc" id="astructmdio_1_1Variable_html"><div class="ttname"><a href="structmdio_1_1Variable.html">mdio::Variable</a></div><div class="ttdoc">A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...</div><div class="ttdef"><b>Definition:</b> variable.h:754</div></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>A future that will be ready when the write is complete. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>mdio/<a class="el" href="variable_8h_source.html">variable.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemdio.html">mdio</a></li><li class="navelem"><a class="el" href="structmdio_1_1Variable.html">Variable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
