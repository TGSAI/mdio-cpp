<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mdio-cpp: MDIO User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="favicon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mdio-cpp
   &#160;<span id="projectnumber">latest</span>
   </div>
   <div id="projectbrief">C++, Cloud native, scalable storage engine for various types of energy data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_USER_GUIDE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MDIO User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal of this user guide is to provide an introduction on how you may want to use <b>MDIO</b> in your own applications.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Table of contents</h1>
<ul>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#how-to-include-mdio">How to include MDIO</a><ul>
<li><a href="#what-a-full-cmake-might-look-like-for-hello-world">What a full CMake might look like for Hello, World!</a></li>
</ul>
</li>
<li><a href="#linking">Linking</a></li>
<li><a href="#how-to-compile">How to compile</a><ul>
<li><a href="#what-a-full-compile-might-look-like-for-hello-world">What a full compile might look like for Hello, World!</a></li>
</ul>
</li>
<li><a href="#concepts">Concepts</a><ul>
<li><a href="#result-based-returns">Result based returns</a></li>
<li><a href="#open-options">Open options</a></li>
<li><a href="#variable-variabledata-and-dataset">Variable, VariableData, and Dataset</a></li>
</ul>
</li>
<li><a href="#example-schema">Example Schema</a></li>
<li><a href="#constructors">Constructors</a></li>
<li><a href="#slicing">Slicing</a></li>
<li><a href="#read">Read</a></li>
<li><a href="#write">Write</a></li>
<li><a href="#efficient-assignment-advanced">Efficient Assignment (Advanced)</a></li>
<li><a href="#mutable-metadata">Mutable Metadata</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md43"></a>
Getting started</h1>
<p>This user guide will assume that you are working in either the provided <a href="https://github.com/TGSAI/mdio-cpp/.devcontainer">devcontainer</a> or have your environment configured according to the <a href="https://github.com/TGSAI/mdio-cpp/README.md">README</a>. Please ensure you have the <a href="https://github.com/TGSAI/mdio-cpp?tab=readme-ov-file#requied-tools">required tools</a> before proceeding. Following these guidelines should ensure a stable and consistent experience and will allow the community to provide better support without any guesswork regarding your environment.</p>
<p>This user guide uses minimal BASH scripting in examples. Commands may need to be altered depending on your operating system.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
How to include MDIO</h1>
<p><b>MDIO</b> currently only supports the <a href="https://cmake.org/">CMake</a> build system. This makes including <b>MDIO</b> straightforward in pre-existing modern CMake projects.</p>
<ol type="1">
<li>Ensure you have the <code>FetchContent</code> module included in your CMake project. ```Cmake include(FetchContent) ```</li>
<li>Select a version of <b>MDIO</b>. Main can be expected to be stable but may update unexpectedly. <a href="https://github.com/TGSAI/mdio-cpp/tags">Tagged</a> versions will also be available if a specific version is desired. New versions will be tagged as significant improvements, utilities, or features are added to the API, as well as when underlying dependencies are updated. ```Cmake FetchContent_Declare( mdio GIT_REPOSITORY <a href="https://github.com/TGSAI/mdio-cpp.git">https://github.com/TGSAI/mdio-cpp.git</a> GIT_TAG main ) ```</li>
<li>Make the <b>MDIO</b> library available to use in your CMake project. ```Cmake FetchContent_MakeAvailable(mdio) ``<code></code></li>
<li><code>Link **MDIO** and its internal dependencies. By default, CMake will not properly link all internal dependencies, so we provide some helpful variables to take the guesswork out of this process. Required is the</code>mdio_INTERNAL_DEPS<code>variable. See the below section on linking for more details. </code>``Cmake target_link_libraries(my_program PRIVATE mdio ${mdio_INTERNAL_DEPS} ) ```</li>
</ol>
<h2><a class="anchor" id="autotoc_md45"></a>
What a full CMake might look like for Hello, World!</h2>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.24)</div>
<div class="line">project(hello_world_project VERSION 1.0.0 LANGUAGES CXX)</div>
<div class="line"> </div>
<div class="line"># Set the C++ standard</div>
<div class="line">set(CMAKE_CXX_STANDARD 17)</div>
<div class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</div>
<div class="line"> </div>
<div class="line"># Include FetchContent module</div>
<div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line"># Fetch the mdio-cpp library from the specified tag</div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  mdio</div>
<div class="line">  GIT_REPOSITORY https://github.com/TGSAI/mdio-cpp.git</div>
<div class="line">  GIT_TAG main</div>
<div class="line">)</div>
<div class="line">FetchContent_MakeAvailable(mdio)</div>
<div class="line"> </div>
<div class="line"># Create an executable target</div>
<div class="line">add_executable(hello_mdio src/hello_mdio.cc)</div>
<div class="line"> </div>
<div class="line"># Link the mdio library to the executable</div>
<div class="line">target_link_libraries(hello_mdio PRIVATE </div>
<div class="line">  mdio</div>
<div class="line">  ${mdio_INTERNAL_DEPS}</div>
<div class="line">)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md46"></a>
Linking</h1>
<p>As mentioned above, linking is not as straight forward as fetching the library and linking it against your binary. We provide a handful of linkable variables that streamline the process.</p><ul>
<li><code>mdio_INTERNAL_DEPS</code> is required and should come immediately after <code>mdio</code> in the linking process</li>
<li><code>mdio_INTERNAL_GCS_DRIVER_DEPS</code> is only required if using <a href="https://cloud.google.com/storage">Google Cloud Store</a>. It should come after <code>mdio_INTERNAL_DEPS</code>.</li>
<li><code>mdio_INTERNAL_S3_DRIVER_DEPS</code> is only required if using <a href="https://aws.amazon.com/s3/">Amazon S3</a>. It should come after <code>mdio_INTERNAL_DEPS</code>.</li>
</ul>
<p>It is worth noting that both the GCS drivers and S3 drivers can be linked at the same time and order does not matter. It is also notable that the order of inclusion <em>should not</em> strictly matter for CMake projects, but maintaining this order will help in quickly troubleshooting any issues you may run into.</p>
<h1><a class="anchor" id="autotoc_md47"></a>
How to compile</h1>
<ol type="1">
<li>In your root directory you should make a new directory called <code>build</code>. ```BASH $ mkdir build ``<code></code></li>
<li><code>Move into the</code>build<code>directory. </code>``BASH $ cd build ```</li>
<li>Run CMake. This may take up to several minutes depending on your system. ```BASH $ cmake .. ``<code></code></li>
<li><code>Run make. This may take up to several minutes depending on your system the first time compiling. Replace</code>my_program<code>with the name of your executable. </code>``BASH $ make -j my_program ```</li>
<li>Run your binary! ```BASH ./my_program ```</li>
</ol>
<h2><a class="anchor" id="autotoc_md48"></a>
What a full compile might look like for Hello, World!</h2>
<div class="fragment"><div class="line">$ cd ~/mdio-cpp/examples/hello_mdio</div>
<div class="line">$ pwd</div>
<div class="line"># /home/BrianMichell/mdio-cpp/examples/hello_mdio</div>
<div class="line">$ mkdir build</div>
<div class="line">$ cd build</div>
<div class="line">$ pwd</div>
<div class="line"># /home/BrianMichell/mdio-cpp/examples/hello_mdio/build</div>
<div class="line">$ cmake ..</div>
<div class="line"># nproc will return the number of processors on your system. This helps speed up the build.</div>
<div class="line">$ make -j$(nproc) hello_mdio</div>
<div class="line">$ ./hello_mdio</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md49"></a>
Concepts</h1>
<h2><a class="anchor" id="autotoc_md50"></a>
Result based returns</h2>
<p><b>MDIO</b> aims to follow the Google style of <a href="https://google.github.io/styleguide/cppguide.html#Exceptions">not throwing exceptions</a>. Instead, we use result based returns wherever an error state could exist. A trivial example of this design pattern is a simple function that tries to divide two integers, and handles the case of divide-by-zero.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">int divide(int numerator, int denominator) {</div>
<div class="line">  if (denominator == 0) {</div>
<div class="line">    throw std::invalid_argument(&quot;Denominator cannot be zero&quot;);</div>
<div class="line">  }</div>
<div class="line">  return numerator / denominator;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  int result;</div>
<div class="line">  try {</div>
<div class="line">    result = divide(10, 0);  // Oops, dividing by zero!</div>
<div class="line">  } catch (const std::invalid_argument&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; &quot;Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    return 1;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; &quot;10 / 0 = &quot; &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Now let's recreate this example with <b>MDIO</b> result based returns instead. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">mdio::Result&lt;int&gt; divide(int numerator, int denominator) {</div>
<div class="line">  if (denominator == 0) {</div>
<div class="line">    return absl::InvalidArgumentError(&quot;Denominator cannot be zero&quot;) ;</div>
<div class="line">  }</div>
<div class="line">  return numerator / denominator;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  auto result = divide(10, 0);  // Oops, still dividing by zero!</div>
<div class="line">  if (!result.status().ok()) {</div>
<div class="line">    std::cerr &lt;&lt; &quot;Got a not-ok result: &quot; &lt;&lt; result.status() &lt;&lt; std::endl;</div>
<div class="line">    return 1;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; &quot;10 / 0 = &quot; &lt;&lt; result.value() &lt;&lt; std::endl;</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Result based returns have the benefit of streamlined error handling, but do slightly increase the verbosity of your code. Adapting to this design pattern may feel uncomfortable for some, but we have found it very robust and clean.</p>
<p>If you find a case where <b>MDIO</b> throws an exception, please submit a <a href="https://github.com/TGSAI/mdio-cpp/issues">bug report</a>.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Open options</h2>
<p>Open options control how we interact with files, and <b>MDIO</b> is no different.</p><ul>
<li><code><a class="el" href="namespacemdio_1_1constants.html#a6788ecca2934df06723540a3c9ad2481" title="Open a pre-existing file.">mdio::constants::kOpen</a></code>: Opens an <b>MDIO</b> for reading and writing. This is only valid for existing MDIO files and will return an error status if it does not exist.</li>
<li><code><a class="el" href="namespacemdio_1_1constants.html#aafefd7c58702ee569c7c4f679c424e0f" title="Create a new file or error if it already exists.">mdio::constants::kCreate</a></code>: Opens a new <b>MDIO</b> for writing. This will return an error if the file already exists.</li>
<li><code><a class="el" href="namespacemdio_1_1constants.html#a94fc8232ef2827af17adf72e37efa052" title="Create a new file and delete any existing file.">mdio::constants::kCreateClean</a></code>: Opens a new <b>MDIO</b> for writing. This <b><u>will</u></b> overwrite existing metadata and stored arrays and should only be used in testing. Users are strongly encouraged to avoid including this option in any production environment as data could be lost if improperly used.</li>
</ul>
<h2><a class="anchor" id="autotoc_md52"></a>
Variable, VariableData, and Dataset</h2>
<p>An <code><a class="el" href="structmdio_1_1Variable.html" title="A templated struct representing an MDIO Variable with a tensorstore. This is an MDIO specified zarr V...">mdio::Variable</a></code> is the C++ representation of the <a href="https://mdio-python.readthedocs.io/en/v1/data_models/version_1.html#mdio.schemas.v1.variable.Variable">Dataset model</a> Variable. It holds no array data, but will be used to both read and write. This process will be explained in more depth below.</p>
<p>An <code><a class="el" href="structmdio_1_1VariableData.html" title="The in-memory representation of the data This object should only be constructed through the Variable:...">mdio::VariableData</a></code> is what will be used to manipulate your array data in-memory.</p>
<p>An <code><a class="el" href="classmdio_1_1Dataset.html" title="The Dataset class The dataset represents a collection of variables sharing a common grid.">mdio::Dataset</a></code> represents a collection of Variables, and their relation with one another.</p>
<p>More information about Variables, their underlying constructs, and relation to XArray can be found <a href="https://github.com/TGSAI/mdio-cpp/issues/8">here</a>.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Example schema</h1>
<p>For all the following examples, this will be the constructor metadata. </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;metadata&quot;: {</div>
<div class="line">    &quot;apiVersion&quot;: &quot;1.0.0&quot;,</div>
<div class="line">    &quot;name&quot;: &quot;Demo MDIO&quot;,</div>
<div class="line">    &quot;createdOn&quot;: &quot;2024-08-01T15:50:00.000000Z&quot;</div>
<div class="line">  },</div>
<div class="line">  &quot;variables&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;name&quot;: &quot;X&quot;,</div>
<div class="line">      &quot;dataType&quot;: &quot;uint32&quot;,</div>
<div class="line">      &quot;dimensions&quot;: [{&quot;name&quot;: &quot;X&quot;, &quot;size&quot;: 51200}]</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;name&quot;: &quot;Y&quot;,</div>
<div class="line">      &quot;dataType&quot;: &quot;uint32&quot;,</div>
<div class="line">      &quot;dimensions&quot;: [{&quot;name&quot;: &quot;Y&quot;, &quot;size&quot;: 51200}]</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;name&quot;: &quot;Grid&quot;,</div>
<div class="line">      &quot;dataType&quot;: &quot;float32&quot;,</div>
<div class="line">      &quot;dimensions&quot;: [&quot;X&quot;, &quot;Y&quot;],</div>
<div class="line">      &quot;metadata&quot;: {</div>
<div class="line">        &quot;chunkGrid&quot;: {</div>
<div class="line">          &quot;name&quot;: &quot;regular&quot;,</div>
<div class="line">          &quot;configuration&quot;: { &quot;chunkShape&quot;: [256, 256] }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md54"></a>
Constructors</h1>
<p>Constructors are based entirely off of the <a href="https://mdio-python.readthedocs.io/en/v1/data_models/version_1.html#reference">MDIO v1</a> Dataset model. Simply specify a JSON schema and provide it to the <code><a class="el" href="classmdio_1_1Dataset.html#af52858456c9c4aa26ea419a0e3070152" title="Constructs a Dataset from a JSON schema. This method will validate the JSON schema against the MDIO D...">mdio::Dataset::from_json()</a></code> method along with the desired path (which can be a relative path, absolute path, or even a GCS or S3 path!), and your open options. </p>
<h3><a class="anchor" id="autotoc_md55"></a>
Example header file defining the get_schema function</h3>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">/**</div>
<div class="line"> * @brief A demo method signature in a header file.</div>
<div class="line"> * @return An MDIO schema in JSON.</div>
<div class="line"> */</div>
<div class="line">nlohmann::json get_schema();</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md56"></a>
Open a brand-new Dataset</h3>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">int main() {</div>
<div class="line">  std::string path = &quot;demo.mdio&quot;;</div>
<div class="line">  nlohmann::json schema = get_schema();</div>
<div class="line">  mdio::Future&lt;mdio::Dataset&gt; dsFuture = mdio::Dataset::from_json(path, schema, mdio::constants::kCreate);</div>
<div class="line">  if (!dsFuture.status().ok()) {</div>
<div class="line">    std::cerr &lt;&lt; &quot;Failed to open a new dataset\n&quot; &lt;&lt; dsFuture.status() &lt;&lt; std::endl;</div>
<div class="line">    return 1;</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  mdio::Dataset ds = dsFuture.value();</div>
<div class="line">  std::cout &lt;&lt; ds &lt;&lt; std::endl;</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md57"></a>
Open an existing Dataset</h3>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">int main() {</div>
<div class="line">  std::string path = &quot;demo.mdio&quot;;</div>
<div class="line">  mdio::Future&lt;mdio::Dataset&gt; dsFuture = mdio::Dataset::Open(path, mdio::constants::kOpen);</div>
<div class="line">  if (!dsFuture.status().ok()) {</div>
<div class="line">    std::cerr &lt;&lt; &quot;Failed to open a new dataset\n&quot; &lt;&lt; dsFuture.status() &lt;&lt; std::endl;</div>
<div class="line">    return 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  mdio::Dataset ds = dsFuture.value();</div>
<div class="line">  std::cout &lt;&lt; ds &lt;&lt; std::endl;</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md58"></a>
Slicing</h1>
<p>Slicing in <b>MDIO</b> is the concept of getting a subset of the data. This could be anything from a single point to a full <a href="https://en.wikipedia.org/wiki/Hypercube">hypercube</a>. Slicing is non-destructive, meaning that if you have pre-existing data that gets sliced that original data will remain untouched.</p>
<p>Currently <b>MDIO</b>-cpp only permits single step slicing to ensure data integrity.</p>
<p><b>MDIO</b> supports slicing on the logical index of <em>dimension coordinates</em> as well as value based slicing of the data contained within the <em>Variable</em>.</p>
<p><b>MDIO</b> offers several ways to describe the slice that is desired.</p>
<ul>
<li>RangeDescriptor: Define a range of data with a <em>label</em>, <em>start</em>, <em>stop</em>, and <em>step</em>.<ul>
<li>Label: The name of the dimension to slice.</li>
<li>Start: The first index <em>or</em> value. This is <u><b>inclusive</b></u>.</li>
<li>Stop: The last index <em>or</em> value. This is <u><b>exclusive</b></u>.</li>
<li>Step: The stride from one index <em>or</em> value to the next. Currently, the step <u><b>must</b></u> be 1.</li>
</ul>
</li>
<li>ValueDescriptor: Define a single value with a <em>label</em> and <em>value</em>.<ul>
<li>Label: The name of the dimension to slice.</li>
<li>The discrete index <em>or</em> value to slice.</li>
</ul>
</li>
<li>ListDescriptor: Define a list of descrete values with a <em>label</em> and a vector of <em>value</em><ul>
<li>Label: The name of the dimension to slice.</li>
<li>Value: A list of indices <em>or</em> values to slice.</li>
</ul>
</li>
</ul>
<p>Each of these descriptors are templated to accept the correctly typed value of the <em>dimension coordinate</em> with a default template value for use in logical indexing.</p>
<p>Below is an example of how we can construct a range descriptor for the <em>X</em> dimension. </p><div class="fragment"><div class="line"><span class="comment">// For logical slicing, we don&#39;t require the template.</span></div>
<div class="line"><a class="code" href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor</a> xIndexSlice = {</div>
<div class="line">  <span class="comment">/*label=*/</span> <span class="stringliteral">&quot;X&quot;</span>,</div>
<div class="line">  <span class="comment">/*start=*/</span> 0,</div>
<div class="line">  <span class="comment">/*stop= */</span> 100,</div>
<div class="line">  <span class="comment">/*step= */</span> 1</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For value-based slicing, the template type must match the Variable&#39;s type.</span></div>
<div class="line"><a class="code" href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor&lt;mdio::dtypes::int32_t&gt;</a> xValueSlice = {</div>
<div class="line">  <span class="comment">/*label=*/</span> <span class="stringliteral">&quot;X&quot;</span>,</div>
<div class="line">  <span class="comment">/*start=*/</span> 16,</div>
<div class="line">  <span class="comment">/*stop= */</span> 216,</div>
<div class="line">  <span class="comment">/*step= */</span> 1</div>
<div class="line">}</div>
<div class="ttc" id="astructmdio_1_1RangeDescriptor_html"><div class="ttname"><a href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor</a></div><div class="ttdoc">A descriptor for slicing a Variable or Dataset.</div><div class="ttdef"><b>Definition:</b> variable.h:76</div></div>
</div><!-- fragment --><p>Below is an example of how we can construct a value descriptor for the <em>Y</em> dimension. </p><div class="fragment"><div class="line"><a class="code" href="structmdio_1_1ValueDescriptor.html">mdio::ValueDescriptor</a> yIndexSlice = {</div>
<div class="line">  <span class="comment">/*label=*/</span> <span class="stringliteral">&quot;Y&quot;</span>,</div>
<div class="line">  <span class="comment">/*value=*/</span> 50</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structmdio_1_1ValueDescriptor.html">mdio::ValueDescriptor&lt;mdio::dtypes::int16_t&gt;</a> yValueSlice = {</div>
<div class="line">  <span class="comment">/*label=*/</span> <span class="stringliteral">&quot;Y&quot;</span>,</div>
<div class="line">  <span class="comment">/*value=*/</span> 12</div>
<div class="line">}</div>
<div class="ttc" id="astructmdio_1_1ValueDescriptor_html"><div class="ttname"><a href="structmdio_1_1ValueDescriptor.html">mdio::ValueDescriptor</a></div><div class="ttdoc">A descriptor for slicing a single dimension value from a Dataset. This structure is not supported for...</div><div class="ttdef"><b>Definition:</b> variable.h:127</div></div>
</div><!-- fragment --><p>Below is an example of how we can construct a list descriptor for the <em>Z</em> dimension. </p><div class="fragment"><div class="line"><a class="code" href="structmdio_1_1RangeDescriptor.html">mdio::RangeDescriptor</a></div>
<div class="line"> </div>
<div class="line">A label must be a dimension as outlined by the **MDIO** [dataset V1 model](https:<span class="comment">//mdio-python.readthedocs.io/en/v1/data_models/version_1.html#mdio.schemas.v1.variable.Variable.dimensions). If the label does not apply to a Variable it will simply be overlooked during the slice (no-op). This means you can safely slice an entire dataset, even if there are Variables with differing dimensions.</span></div>
<div class="line"> </div>
<div class="line">The recommended method to apply slices is at the dataset level. This will ensure consistent dimensions across your entire dataset.</div>
<div class="line">1. Construct your slice descriptors.</div>
<div class="line">2. Slice the dataset with the `isel` method.</div>
<div class="line">3. Operate on the returned dataset.</div>
<div class="line"> </div>
<div class="line">Slicing is curcial when working on large datasets that would not fit into memory <span class="keywordflow">for</span> reasons explained in the Read section below.</div>
<div class="line">```C++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  std::string path = <span class="stringliteral">&quot;demo.mdio&quot;</span>;</div>
<div class="line">  mdio::Future&lt;mdio::Dataset&gt; dsFut = <a class="code" href="classmdio_1_1Dataset.html#a60effe20b3c7c048d73a71e19f6a80bf">mdio::Dataset::Open</a>(path, <a class="code" href="namespacemdio_1_1constants.html#a6788ecca2934df06723540a3c9ad2481">mdio::constants::kOpen</a>);</div>
<div class="line">  <span class="keywordflow">if</span> (!dsFut.status().ok()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open dataset: &quot;</span> &lt;&lt; dsFut.status() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classmdio_1_1Dataset.html">mdio::Dataset</a> ds = dsFut.value();</div>
<div class="line">  <a class="code" href="structmdio_1_1SliceDescriptor.html">mdio::SliceDescriptor</a> xSlice = {<span class="stringliteral">&quot;X&quot;</span>, 0, 100, 1};</div>
<div class="line">  <a class="code" href="structmdio_1_1SliceDescriptor.html">mdio::SliceDescriptor</a> ySlice = {<span class="stringliteral">&quot;Y&quot;</span>, 50, 150, 1};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We can pass any number of slices to the method, in any order.</span></div>
<div class="line">  mdio::Result&lt;mdio::Dataset&gt; slicedRes = ds.<a class="code" href="classmdio_1_1Dataset.html#a273fbf7254f4c75effa324a1a531d6c0">isel</a>(xSlice, ySlice);</div>
<div class="line">  <span class="keywordflow">if</span> (!slicedRes.status().ok()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to slice dataset: &quot;</span> &lt;&lt; slicedRes.status() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classmdio_1_1Dataset.html">mdio::Dataset</a> slicedDs = slicedRes.value();</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; ds &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;==============================&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; slicedDs &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassmdio_1_1Dataset_html"><div class="ttname"><a href="classmdio_1_1Dataset.html">mdio::Dataset</a></div><div class="ttdoc">The Dataset class The dataset represents a collection of variables sharing a common grid.</div><div class="ttdef"><b>Definition:</b> dataset.h:400</div></div>
<div class="ttc" id="aclassmdio_1_1Dataset_html_a273fbf7254f4c75effa324a1a531d6c0"><div class="ttname"><a href="classmdio_1_1Dataset.html#a273fbf7254f4c75effa324a1a531d6c0">mdio::Dataset::isel</a></div><div class="ttdeci">Result&lt; Dataset &gt; isel(Descriptors &amp;... descriptors)</div><div class="ttdoc">Performs an indexed slice on the Dataset.</div><div class="ttdef"><b>Definition:</b> dataset.h:534</div></div>
<div class="ttc" id="aclassmdio_1_1Dataset_html_a60effe20b3c7c048d73a71e19f6a80bf"><div class="ttname"><a href="classmdio_1_1Dataset.html#a60effe20b3c7c048d73a71e19f6a80bf">mdio::Dataset::Open</a></div><div class="ttdeci">static std::enable_if_t&lt;(std::is_same_v&lt; S, std::string &gt;), Future&lt; Dataset &gt; &gt; Open(const S &amp;dataset_path, Option &amp;&amp;... options)</div><div class="ttdoc">Opens a Dataset from a file path. This method will assume that the Dataset already exists at the spec...</div><div class="ttdef"><b>Definition:</b> dataset.h:1038</div></div>
<div class="ttc" id="anamespacemdio_1_1constants_html_a6788ecca2934df06723540a3c9ad2481"><div class="ttname"><a href="namespacemdio_1_1constants.html#a6788ecca2934df06723540a3c9ad2481">mdio::constants::kOpen</a></div><div class="ttdeci">constexpr auto kOpen</div><div class="ttdoc">Open a pre-existing file.</div><div class="ttdef"><b>Definition:</b> impl.h:110</div></div>
<div class="ttc" id="astructmdio_1_1SliceDescriptor_html"><div class="ttname"><a href="structmdio_1_1SliceDescriptor.html">mdio::SliceDescriptor</a></div><div class="ttdoc">A descriptor for slicing a Variable. A struct representing how to slice a Variable or Dataset....</div><div class="ttdef"><b>Definition:</b> variable.h:109</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md59"></a>
Read</h1>
<p>Reading <b>MDIO</b> is performed lazily, which means that we will only read a small amount of metadata from disk when the <b>MDIO</b> is opened. In order to read the array data from disk, we will need to actively solicit the read. It's important to note that once we solicit the read, all of the data will be read at once in parallel automatically. If the data is sliced before reading, only the <a href="https://mdio-python.readthedocs.io/en/v1/data_models/version_1.html#mdio.schemas.v1.variable.VariableMetadata.chunk_grid">chunk grids</a> contained within the slice are read.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">/** </div>
<div class="line"> * @brief Reads an arbitrary Variable into memory.</div>
<div class="line"> * @return An Ok result if the process worked as expected.</div>
<div class="line"> */</div>
<div class="line">mdio::Result&lt;void&gt; read_and_return_result(mdio::Dataset&amp; ds) {</div>
<div class="line">  // Pick the first key in the keys list.</div>
<div class="line">  std::string variableToRead = ds.variables.get_keys().front();</div>
<div class="line">  // Get the mdio::Variable object</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variable, ds.variables.at(key));</div>
<div class="line">  // Solicit the read. This happens asynchronously so we could do other things while the data is read.</div>
<div class="line">  auto readFuture = variable.Read();</div>
<div class="line">  return readFuture.status();  // We are forcing the future to block here.</div>
<div class="line">}</div>
</div><!-- fragment --><p> This example isn't very useful on its own, so lets step it up by giving it a type and view the array. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">/** </div>
<div class="line"> * @brief Reads an arbitrary Variable into memory.</div>
<div class="line"> * @return An Ok result if the process worked as expected.</div>
<div class="line"> */</div>
<div class="line">mdio::Result&lt;void&gt; read_and_return_result(mdio::Dataset&amp; ds) {</div>
<div class="line">  // We elect to use the `get_iterable_accessor` because the order is sorted.</div>
<div class="line">  std::string variableToRead = ds.variables.get_iterable_accessor().front();  // &quot;Grid&quot;</div>
<div class="line">  // We use `.get&lt;T&gt;()` so we can use the `get_data_accessor()` in a simple and easy way.</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variable, ds.variables.get&lt;mdio::dtypes::float32_t&gt;(variableToRead));</div>
<div class="line">  auto readFuture = variable.Read();</div>
<div class="line">  if (!readFuture.status().ok()) {</div>
<div class="line">    return readFuture.status();</div>
<div class="line">  }</div>
<div class="line">  auto variableData = readFuture.value();</div>
<div class="line"> </div>
<div class="line">  // This gives us our array</div>
<div class="line">  auto arrayValues = variableData.get_data_accessor();</div>
<div class="line"> </div>
<div class="line">  for (mdio::Index x=0; x&lt;10; x++) {</div>
<div class="line">    for (mdio::Index y=0; y&lt;10; y++) {</div>
<div class="line">      std::cout &lt;&lt; arrayValues({x, y}) &lt;&lt; &quot; &quot;;</div>
<div class="line">      // You may also use bracket notation here if you wish</div>
<div class="line">      // std::cout &lt;&lt; arrayValues[x][y] &lt;&lt; &quot; &quot;;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return absl::OkStatus();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md60"></a>
Write</h1>
<p>Writing <b>MDIO</b> data happens in parallel automatically, just like reading. We also need to have either read the values, or generated them from an empty Variable.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">mdio::Result&lt;void&gt; write_and_return_result(mdio::Dataset&amp; ds) {</div>
<div class="line">  std::string variableToWrite = ds.variables.get_iterable_accessor().front();  // &quot;Grid&quot;</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variable, ds.variables.get&lt;mdio::dtypes::float32_t&gt;(variableToWrite));</div>
<div class="line">  auto readFuture = variable.Read();</div>
<div class="line"> </div>
<div class="line">  if (!readFuture.status().ok()) {</div>
<div class="line">    return readFuture.status();</div>
<div class="line">  }</div>
<div class="line">  auto variableData = readFuture.value();</div>
<div class="line"> </div>
<div class="line">  auto arrayValues = variableData.get_data_accessor();</div>
<div class="line"> </div>
<div class="line">  float value = 0.0;</div>
<div class="line">  for (mdio::Index x=0; x&lt;10; x++) {</div>
<div class="line">    for (mdio::Index y=0; y&lt;10; y++) {</div>
<div class="line">      // The access pattern is the same as before, but now we&#39;re setting instead of reading</div>
<div class="line">      arrayValues({x, y}) = value++;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // Writing is async, we could be performing more operations here if we wished.</div>
<div class="line">  auto writeFuture = variable.Write(variableData);</div>
<div class="line">  return writeFuture.status();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Since we are overwriting all of our data anyway, we can also use the <code>from_variable</code> function to get our <code>VariableData</code> object. This function is only recommended if you are the one originating all the data and must be used with caution. Not being chunk-aligned in writes using the <code>from_variable</code> method may result in undefined behavior and is not guarenteed to remain consistent between versions of mdio-cpp.</p>
<p>If you are ever in doubt, use the above method of reading to get the VariableData object. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">mdio::Result&lt;void&gt; overwrite_and_return_result(mdio::Dataset&amp; ds) {</div>
<div class="line">  std::string variableToWrite = ds.variables.get_iterable_accessor().front();  // &quot;Grid&quot;</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variable, ds.variables.get&lt;mdio::dtypes::float32_t&gt;(variableToWrite));</div>
<div class="line">  // This allows for shorter overall code and should avoid larger reads</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variableData, mdio::from_variable&lt;mdio::dtypes::float32_t&gt;(variable));</div>
<div class="line"> </div>
<div class="line">  auto arrayValues = variableData.get_data_accessor();</div>
<div class="line"> </div>
<div class="line">  float value = 0.0;</div>
<div class="line">  for (mdio::Index x=0; x&lt;10; x++) {</div>
<div class="line">    for (mdio::Index y=0; y&lt;10; y++) {</div>
<div class="line">      arrayValues({x, y}) = value++;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  auto writeFuture = variable.Write(variableData);</div>
<div class="line">  return writeFuture.status();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md61"></a>
Efficient Assignment (Advanced)</h1>
<p>For small datasets, setting data elements one at a time may be reasonable, but as your dataset grows, so too does the time it takes to copy from one array to another. The typical way to handle this is to use the STL <code>std::memcpy</code> function. When dealing with full datasets, this works exactly as expected, copy from one address or container to another. If the dataset is sliced, as would be expected for large datasets, there is an additional challenge that is presented. When slicing outside of the logical origin, there is an offset in memory that must be taken into account. <b>MDIO</b> does provide a convienent method to getting that offset, but as with any low-level operation care must be taken. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">mdio::Result&lt;void&gt; copy_overwrite_and_return(mdio::Dataset&amp; ds) {</div>
<div class="line">  std::string variableToWrite = ds.variables.get_iterable_accessor().front();  // &quot;Grid&quot;</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variable, ds.variables.get&lt;mdio::dtypes::float32_t&gt;(variableToWrite));</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variableData, mdio::from_variable&lt;mdio::dtypes::float32_t&gt;(variable));</div>
<div class="line"> </div>
<div class="line">  // We will get the raw pointer first, and then cast it to a properly typed pointer.</div>
<div class="line">  auto voidPtr = variableData.get_data_accessor().data();  // Note the `.data()` call to get the raw pointer.</div>
<div class="line">  auto typedPtr = static_cast&lt;mdio::dtypes::float32_t*&gt;(voidPtr); </div>
<div class="line"> </div>
<div class="line">  // We&#39;ll generate some inert data to copy</div>
<div class="line">  std::vector&lt;mdio::dtypes::float32_t&gt; fill_val(51200);</div>
<div class="line">  for (auto i = 0; i &lt; 51200; i++) {</div>
<div class="line">    fill_val[i] = float(i*.0002);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  const auto offsetValue = variableData.get_flattened_offset();</div>
<div class="line">  std::size_t increment = 0;</div>
<div class="line">  for (auto i=0; i&lt;51200; i++) {</div>
<div class="line">    std::memcpy(&amp;typedPtr[offsetValue], fill_val.data(), sizeof(mdio::dtypes::float32_t)*51200);</div>
<div class="line">    increment += 51200;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  auto writeFuture = variable.Write(variableData);</div>
<div class="line">  return writeFuture.status();</div>
<div class="line">}</div>
</div><!-- fragment --><p> That example is good for demonstration purposes, but for a practical application it's too inflexible. Lets fix it by slicing our dataset and copying the data. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">mdio::Result&lt;void&gt; copy_overwrite_and_return(mdio::Dataset&amp; ds) {</div>
<div class="line">  mdio::SliceDescriptor xSlice = {&quot;X&quot;, 256, 512, 1};</div>
<div class="line">  mdio::SliceDescriptor ySlice = {&quot;Y&quot;, 512, 768, 1};</div>
<div class="line"> </div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto slicedDs, ds.isel(xSlice, ySlice));</div>
<div class="line"> </div>
<div class="line">  std::string variableToWrite = slicedDs.variables.get_iterable_accessor().front();  // &quot;Grid&quot;</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variable, slicedDs.variables.get&lt;mdio::dtypes::float32_t&gt;(variableToWrite));</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto variableData, mdio::from_variable&lt;mdio::dtypes::float32_t&gt;(variable));</div>
<div class="line"> </div>
<div class="line">  // We will get the raw pointer first, and then cast it to a properly typed pointer.</div>
<div class="line">  auto voidPtr = variableData.get_data_accessor().data();  // Note the `.data()` call to get the raw pointer.</div>
<div class="line">  auto typedPtr = static_cast&lt;mdio::dtypes::float32_t*&gt;(voidPtr); </div>
<div class="line"> </div>
<div class="line">  auto numSamples = variable.num_samples();</div>
<div class="line"> </div>
<div class="line">  // We&#39;ll generate some inert data to copy</div>
<div class="line">  std::vector&lt;mdio::dtypes::float32_t&gt; fill_val(numSamples);</div>
<div class="line">  for (auto i = 0; i &lt; numSamples; i++) {</div>
<div class="line">    fill_val[i] = float(i*.0002);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  const auto offsetValue = variableData.get_flattened_offset();</div>
<div class="line">  std::size_t increment = 0;</div>
<div class="line">  for (auto i=0; i&lt;1; i++) {</div>
<div class="line">    std::memcpy(&amp;typedPtr[offsetValue], fill_val.data(), sizeof(mdio::dtypes::float32_t)*fill_val.size());</div>
<div class="line">    increment += numSamples;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  auto writeFuture = variable.Write(variableData);</div>
<div class="line">  return writeFuture.status();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md62"></a>
Mutable Metadata</h1>
<p>You may have noticed that <a href="https://mdio-python.readthedocs.io/en/v1/data_models/version_1.html#mdio.schemas.v1.stats.StatisticsMetadata">summary statistics</a> is part of the dataset model, but how can you include them in your Variable before you've even seen the data? This thought exercise assumes that the answer is "You can't!". To address this problem we allow a limited portion of the metadata to be changed at the Variable level. </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">mdio::Future&lt;void&gt; UpdateStats(mdio::Dataset&amp; ds) {</div>
<div class="line">  // We can use the .at method since we&#39;re not reading data from disk</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto gridVariable, ds.variables.at(&quot;Grid&quot;));</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto xVariable, ds.variables.at(&quot;X&quot;));</div>
<div class="line">  MDIO_ASSIGN_OR_RETURN(auto yVariable, ds.variables.at(&quot;Y&quot;));</div>
<div class="line"> </div>
<div class="line">  // Get the attributes JSON</div>
<div class="line">  nlohmann::json gridAttrs = gridVariable.GetAttributes();</div>
<div class="line">  nlohmann::json xAttrs = xVariable.GetAttributes();</div>
<div class="line">  nlohmann::json yAttrs = yVariable.GetAttributes();</div>
<div class="line"> </div>
<div class="line">  // Modify the attributes in memory</div>
<div class="line">  xAttrs[&quot;attributes&quot;][&quot;foo&quot;] = &quot;bar&quot;;</div>
<div class="line">  yAttrs[&quot;attributes&quot;][&quot;ping&quot;] = &quot;pong&quot;;</div>
<div class="line">  // We had no stats in the original object, so we must populate all the required fields!</div>
<div class="line">  gridAttrs[&quot;statsV1&quot;][&quot;histogram&quot;][&quot;binCenters&quot;] = {5, 15, 25, 35, 45};</div>
<div class="line">  gridAttrs[&quot;statsV1&quot;][&quot;histogram&quot;][&quot;counts&quot;] = {1, 2, 3, 4, 5};</div>
<div class="line">  gridAttrs[&quot;statsV1&quot;][&quot;count&quot;] = 51200;</div>
<div class="line">  gridAttrs[&quot;statsV1&quot;][&quot;min&quot;] = 0.0;</div>
<div class="line">  gridAttrs[&quot;statsV1&quot;][&quot;max&quot;] = 50.0;</div>
<div class="line">  gridAttrs[&quot;statsV1&quot;][&quot;sum&quot;] = 52.7;</div>
<div class="line">  gridAttrs[&quot;statsV1&quot;][&quot;sumSquares&quot;] = 2777.29;</div>
<div class="line">  gridAttrs[&quot;attributes&quot;][&quot;randomStats&quot;] = true;</div>
<div class="line"> </div>
<div class="line">  // Update the attributes in memory associated with their Variable</div>
<div class="line">  auto xUpdateRes = xVariable.UpdateAttributes(xAttrs);</div>
<div class="line">  if (!xUpdateRes.status().ok()) {</div>
<div class="line">    return xUpdateRes.status();</div>
<div class="line">  }</div>
<div class="line">  auto yUpdateRes = yVariable.UpdateAttributes(yAttrs);</div>
<div class="line">  if (!yUpdateRes.status().ok()) {</div>
<div class="line">    return yUpdateRes.status();</div>
<div class="line">  }</div>
<div class="line">  // Since we are using an integer historgram we need to specify the type. It can be float32 or int32.</div>
<div class="line">  auto gridUpdateRes = gridVariable.UpdateAttributes&lt;mdio::dtypes::int32_t&gt;(gridAttrs);</div>
<div class="line">  if (!gridUpdateRes.status().ok()) {</div>
<div class="line">    return gridUpdateRes.status();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // The commit step will commit the changes in memory to disk</div>
<div class="line">  return ds.CommitMetadata();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
